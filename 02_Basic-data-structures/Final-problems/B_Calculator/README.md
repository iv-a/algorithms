<h1 align="center">B. Калькулятор</h1>

<h5 align="center">
<a href="#limits">Ограничения</a>
•
<a href="#task">Условие задачи</a>
•
<a href="#input">Формат ввода</a>
•
<a href="#output">Формат вывода</a>
•
<a href="#examples">Примеры</a>
•
<a href="#solution">Решение</a>
</h5>

<br>

<table id="limits">
<tbody>
<tr>
<td>
<b>Ограничение времени</b>
</td>
<td>
1 секунда
</td>
</tr>
<tr>
<td>
<b>Ограничение памяти</b>
</td>
<td>
64Mb
</td>
</tr>
<tr>
<td>
<b>Ввод</b>
</td>
<td>
стандартный ввод или input.txt
</td>
</tr>
<tr>
<td>
<b>Вывод</b>
</td>
<td>
стандартный вывод или output.txt
</td>
</tr>
</tbody>
</table>

<h2 id="task">Условие задачи</h2>

Задание связано с обратной польской нотацией. Она используется для парсинга арифметических выражений. Еще её иногда называют постфиксной нотацией.

В постфиксной нотации операнды расположены перед знаками операций.

<b>Пример 1:</b>
<pre>3 4 +</pre>

означает 3 + 4 и равно 7

<b>Пример 2:</b>
<pre>12 5 /</pre>
Так как деление целочисленное, то в результате получим 2.

<b>Пример 3:</b>
<pre>10 2 4 * -</pre>
означает 10 - 2 * 4 и равно 2

Разберём последний пример подробнее:

Знак * стоит сразу после чисел <i>2</i> и <i>4</i>, значит к ним нужно применить операцию, которую этот знак обозначает, то есть перемножить эти два числа. В результате получим <i>8</i>.

После этого выражение приобретёт вид:

<pre>10 8 -</pre>

Операцию «минус» нужно применить к двум идущим перед ней числам, то есть <i>10</i> и <i>8</i>. В итоге получаем <i>2</i>.

Рассмотрим алгоритм более подробно. Для его реализации будем использовать стек.

Для вычисления значения выражения, записанного в обратной польской нотации, нужно считывать выражение слева направо и придерживаться следующих шагов:

<ol>
<li>Обработка входного символа:</li>
<ul>
<li>Если на вход подан операнд, он помещается на вершину стека.</li>
<li>Если на вход подан знак операции, то эта операция выполняется над требуемым количеством значений, взятых из стека в порядке добавления. Результат выполненной операции помещается на вершину стека.</li>
</ul>
<li>Если входной набор символов обработан не полностью, перейти к шагу 1.</li>
<li>После полной обработки входного набора символов результат вычисления выражения находится в вершине стека. Если в стеке осталось несколько чисел, то надо вывести только верхний элемент.</li>
</ol>

<b>Замечание про отрицательные числа и деление:</b> в этой задаче под делением понимается математическое целочисленное деление. Это значит, что округление всегда происходит вниз. А именно: если <i>a / b = c</i>, то <i>b ⋅ c</i> — это наибольшее число, которое не превосходит <i>a</i> и одновременно делится без остатка на <i>b</i>.

Например, <i>-1 / 3 = -1</i>. Будьте осторожны: в C++, Java и Go, например, деление чисел работает иначе.

В текущей задаче гарантируется, что деления на отрицательное число нет.

<h2 id="input">Формат ввода</h2>

В единственной строке дано выражение, записанное в обратной польской нотации. Числа и арифметические операции записаны через пробел.

На вход могут подаваться операции: <i>+, -, *, /</i> и числа, по модулю не превосходящие <i>10 000</i>.

Гарантируется, что значение промежуточных выражений в тестовых данных по модулю не больше <i>50 000</i>.

<h2 id="output">Формат вывода</h2>

Выведите единственное число — значение выражения.

<h2 id="examples">Примеры</h2>

<h4>Пример 1</h4>
<ul>
<h6>Ввод</h6>
<pre>
2 1 + 3 *
</pre>

<h6>Вывод</h6>
<pre>
9
</pre>
</ul>

<hr>

<h4>Пример 2</h4>
<ul>
<h6>Ввод</h6>
<pre>
7 2 + 4 * 2 +
</pre>

<h6>Вывод</h6>
<pre>
38
</pre>
</ul>

<h2 id="solution">Решение</h2>

```javascript
/*
-- ПРИНЦИП РАБОТЫ --
Задача решена с использованием стека на основе динамического массива.
Функция calculator принимает на вход массив операндов и операторов.
Далее в цикле проходимся по этому массиву и сравниваем каждый элемент с операторами.
Если текущий элемент является операндом, то он попадает на вершину стека.
Если же текущий элемент является оператором, то функция getOperands возвращает из
стека два верхних элемента. При этом верхний из них будет вторым операндом, а нижний - первым.
Далее над этими операндами выполняется соответствующая операция,
результат которой попадает на вершину стека.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
В реализации учтено, что под делением подразумевается математическое целочисленное деление,
поэтому деление оприцательных чисел выполняется корректно.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Операции чтения и записи значений в массив стоят O(1),
Поскольку мы в цикле проходимся по каждому элементу входного массива expression,
то временная сложность алгоритма O(n);

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Поскольку массив динамический и при считываниии строки в исходный массив expression
записываются все элементы строки, то пространственная сложность алгоритма O(n).

*/

const readline = require('readline');
const io_interface = readline.createInterface({input: process.stdin});

const additionOperator = '+',
  subtractionOperator = '-',
  divisionOperator = '/',
  multiplicationOperator = '*';

class Stack {
  constructor() {
    this.items = [];
  }

  push(item) {
    this.items.push(item);
  }

  pop() {
    return this.items.pop();
  }
}

function getOperands(stack) {
  return [stack.pop(), stack.pop()];
}

function calculator(expression) {
  const stack = new Stack();

  for (let element of expression) {
    if (element === additionOperator) {
      const [ secondOperand, firstOperand ] = getOperands(stack);
      stack.push(firstOperand + secondOperand);
    } else if (element === subtractionOperator) {
      const [ secondOperand, firstOperand ] = getOperands(stack);
      stack.push(firstOperand - secondOperand);
    } else if (element === multiplicationOperator) {
      const [ secondOperand, firstOperand ] = getOperands(stack);
      stack.push(firstOperand * secondOperand);
    } else if (element === divisionOperator) {
      const [ secondOperand, firstOperand ] = getOperands(stack);
      stack.push(Math.floor(firstOperand / secondOperand));
    } else {
      stack.push(Number(element));
    }
  }
  return stack.pop();
}

io_interface.on('line', function (line) {
  const inputArray = line.split(' ');
  console.log(calculator(inputArray));
});
```
<table>
  <thead>
    <tr>
      <th>Вердикт</th>
      <th>Компилятор</th>
      <th>Время</th>
      <th>Память</th>
    </tr>
  </thead>
  <tbody>
<tr align="center">
<td>OK</td>
<td>Node.js 14.15.5</td>
<td>65ms</td>
<td>5.75Mb</td>
</tr>
  </tbody>
</table>