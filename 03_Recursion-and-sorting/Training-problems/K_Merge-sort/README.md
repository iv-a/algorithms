<h1 align="center">K. Рекурсивные числа Фибоначчи</h1>

<h5 align="center">
<a href="#limits">Ограничения</a>
•
<a href="#task">Условие задачи</a>
•
<a href="#input">Формат ввода</a>
•
<a href="#output">Формат вывода</a>
•
<a href="#solution">Решение</a>
</h5>

<br>

<table id="limits">
<tbody>
<tr>
<td>
<b>Ограничение времени</b>
</td>
<td>
2 секунды
</td>
</tr>
<tr>
<td>
<b>Ограничение памяти</b>
</td>
<td>
64Mb
</td>
</tr>
<tr>
<td>
<b>Ввод</b>
</td>
<td>
стандартный ввод или input.txt
</td>
</tr>
<tr>
<td>
<b>Вывод</b>
</td>
<td>
стандартный вывод или output.txt
</td>
</tr>
</tbody>
</table>

<h2 id="task">Условие задачи</h2>

Гоше дали задание написать красивую сортировку слиянием. Поэтому Гоше обязательно надо реализовать отдельно функцию merge и функцию merge_sort.
Функция merge принимает два отсортированных массива, сливает их в один отсортированный массив и возвращает его. Если требуемая сигнатура имеет вид merge(array, left, mid, right), то первый массив задаётся полуинтервалом
[
l
e
f
t
,
m
i
d
)
массива array, а второй – полуинтервалом
[
m
i
d
,
r
i
g
h
t
)
массива array.
Функция merge_sort принимает некоторый подмассив, который нужно отсортировать. Подмассив задаётся полуинтервалом — его началом и концом. Функция должна отсортировать передаваемый в неё подмассив, она ничего не возвращает.
Функция merge_sort разбивает полуинтервал на две половинки и рекурсивно вызывает сортировку отдельно для каждой. Затем два отсортированных массива сливаются в один с помощью merge.
Заметьте, что в функции передаются именно полуинтервалы
[
b
e
g
i
n
,
e
n
d
)
, то есть правый конец не включается. Например, если вызвать merge_sort(arr, 0, 4), где
a
r
r
=
[
4
,
5
,
3
,
0
,
1
,
2
]
, то будут отсортированы только первые четыре элемента, изменённый массив будет выглядеть как
a
r
r
=
[
0
,
3
,
4
,
5
,
1
,
2
]
.
Реализуйте эти две функции.
Мы рекомендуем воспользоваться заготовками кода для данной задачи, расположенными по ссылке.

<h2 id="input">Формат ввода</h2>

Передаваемый в функции массив состоит из целых чисел, не превосходящих по модулю
1
0
9
. Длина сортируемого диапазона не превосходит
1
0
5
.

<h2 id="output">Формат вывода</h2>

При написании и отправке решений соблюдайте следующие правила:
Отправляйте решение в виде файла. Если текст решения будет вставлен в форму, то будет возвращена ошибка.
В качестве компилятора выберите  Make.
На Java назовите файл с решением Solution.java и реализуйте внутри класса указанные функции, для C# – Solution.cs
Для остальных решений не используйте в качестве имени файла слово solution
Укажите правильное разрешение для файла (.cpp, .java, .go. .js, .py). Для решений на C++ разрешение .h не поддерживается.

<h2 id="solution">Решение</h2>

```javascript
function merge(arr, left, mid, right) {
  let l = 0, r = 0;
  const result = new Array(right - left);

  while (left + l < mid && mid + r < right) {
    if (arr[left + l] < arr[mid + r]) {
      result[l + r] = arr[left + l];
      l++;
    } else {
      result[l + r] = arr[mid + r];
      r++;
    }
  }

  while (left + l < mid) {
    result[l + r] = arr[left + l];
    l++;
  }

  while (mid + r < right) {
    result[l + r] = arr[mid + r];
    r++;
  }

  return result;
}

function merge_sort(arr, left, right) {
  if (left + 1 >= right) {
    return;
  }
  let mid = (left + right) >> 1;
  merge_sort(arr, left, mid);
  merge_sort(arr, mid, right);
  let mergedArr = merge(arr, left, mid, right);
  for (let i = left, j = 0; i < right; i++, j++) {
    arr[i] = mergedArr[j];
  }
}

// function test() {
//   var a = [1, 4, 9, 2, 10, 11];
//   var b = merge(a, 0, 3, 6);
//   console.log(b);
//   var expected = [1, 2, 4, 9, 10, 11];
//
//   var c = [1, 4, 2, 10, 1, 2];
//   merge_sort(c, 0, 6);
//   console.log(c);
//   expected = [1, 1, 2, 2, 4, 10];
// }
//
// test();
```
<table>
  <thead>
    <tr>
      <th>Вердикт</th>
      <th>Компилятор</th>
      <th>Время</th>
      <th>Память</th>
    </tr>
  </thead>
  <tbody>
<tr align="center">
<td>OK</td>
<td>Node.js 14.15.5</td>
<td>317ms</td>
<td>41.98Mb</td>
</tr>
  </tbody>
</table>